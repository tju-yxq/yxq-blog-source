---
title:       "计算机系统基础1 笔记3"
subtitle:    ""
layout:      "single"
description: "x86_64汇编语言"
date:        2025-07-12
author:      "小段子"
image:       "/img/home-bg-jeep.jpg"
tags:        ["计算机系统"]
categories:  ["计算机系统"]
---

## 汇编指令格式

[label :] [opcode] [operand 1] [,oprand 2]
标号 操作码 操作数1

### 操作数类型

- **立即数（整数常量）**
  - 例 `$0x400`, `$-533`
- **寄存器**
  - 例如：
    - `%rax`, `%r13`
    - `(%rsp 作栈指针)`
- **存储器**
  - 地址指向的连续的8个字节
  - 例：
    - `(%rax)` 表示调用rax存储的地址对应的内存

## 数据传送指令

### mov

#### 操作码后缀

| C语言类型声明 | 数据类型         | 后缀 | 大小 |
| ------------- | ---------------- | ---- | ---- |
| char          | Byte             | b    | 1    |
| short         | Word             | w    | 2    |
| int           | Double Word      | l    | 4    |
| long          | Quad Word        | q    | 8    |
| char*         | Quad Word        | q    | 8    |
| float         | Single precision | s    | 4    |
| double        | Double precision | l    | 8    |

还有一些特别的组合后缀（z表示0扩展，s表示符号位扩展）![1749304851955](image/第三章程序的机器级表示/1749304851955.png)![1749304862371](image/第三章程序的机器级表示/1749304862371.png)

- `MOV S,D` 即 `S->D`
- 例：
  - `movq %rdi ,%rax` 表示把rdi中的数复制到rax里

特别情况（我感觉不会考啊）![1749305079220](image/第三章程序的机器级表示/1749305079220.png)

- 如果把位数低的数x传入到原本8字节都填充的寄存器中：
  - `if (x位数 == 32) {寄存器高32位会清零}`
  - `if (x位数 != 32) {只覆盖自己长度的数值，对于高位的不覆盖}`

### 存储器寻址方式

- **间接寻址**（和c中指针作用相同）
  - `(Rb)`
    例：`(%rax)` 取rax存储的地址指向的内存
- **基地址+偏移量**
  - `D(Rb)`
    例：`8(%rax)`
- **变址寻址**
  - `D(Rb,Ri)`
    例：`8(%rdi,rsi)` → `8 + rdi + rsi`
- **比例变址寻址**
  - `D(Rb,Ri,s)`
    例：`8(%rax,%rdx,4)` → `8 + rax + rdx * 4`

结合下图食用：
![1749304477171](./1749304477171-1758624338481-4.png)
![1749304506925](./1749304506925.png)

## 栈指令

### pushq S

将S入栈（效果如下）：
subq $8,%rsp // 栈指针向下移动8字节
movq S,(%rsp) // 将S的数值丢入指针所指空间

### popq D

将8字节（四字）出栈：

## 算数和逻辑操作

### 地址计算指令

#### lea（load effective address）

- **形式**：`lea src dst`
  - `src`：是寻址模式的表达式
  - `dst`：目的地
- **用途**：计算地址（不用引用内存数值）
  如图：
  ![1749352131803](./1749352131803.png)
  （用c的话来说就是mov解引用，而lea不)

### 单操作数指令

| 指令          | 效果                |
| ------------- | ------------------- |
| `incq Dest` | `Dest = Dest + 1` |
| `decq Dest` | `Dest = Dest - 1` |
| `negq Dest` | `Dest = -Dest`    |
| `notq Dest` | `Dest = ~Dest`    |

### 双操作数指令

![1749352973136](./1749352973136.png)
*(逻辑右移(logical)不考虑符号位，算数右移(arithmetic)考虑符号位)*

## 控制

### 前情提要

- 除了整数寄存器，CPU还维护一组单个位的**条件码寄存器**，描述最近算术或逻辑操作的属性
- **特别注明**：
  - `lea`操作不会改变任何条件码（用于地址计算）
  - 双操作指令会改变条件码
  - 对于逻辑操作：进位标志和溢出标志设置为0
  - 对于移位操作：进位标志设置为最后一个被移出的位，溢出标志为0
  - `INC`和 `DEC`：设置溢出和零标志，不改变进位标志

### 常用条件码

| 标志 | 描述                     | C等效检查                     |
| ---- | ------------------------ | ----------------------------- |
| CF   | 最近操作使最高位产生进位 | `(unsigned)t < (unsigned)a` |
| ZF   | 最近操作结果为0          | `t == 0`                    |
| SF   | 最近操作结果为负数       | `t < 0`                     |
| OF   | 最近操作导致补码溢出     | `(a<0&&b<0&&!t<0)             |

### 修改条件码

#### 寄存器比较指令 cmp

- **格式**：`cmp src2 src1`
  类似 `sub`，执行 `src1 - src2`但不改变目标操作数
  ![1749354916226](./1749354916226.png)
  （被置位=设置为1)

#### 位比较指令 test

- 类似 `and`，只设置条件码，不改变目标操作数
- **格式**：`test src2 src1`![1749355023913](./1749355023913.png)
- **用途**：
  - 测试寄存器值：`testq %rax,%rax`（检查%rax是负/零/正）
  - 测试特定位：一个操作数是掩码

### 访问指令码(读取条件码)

#### setX

![1749366153762](./1749366153762.png)

### if else的汇编实现

#### 跳转指令 jX

![1749366641156](./1749366641156.png)

- **jmp讲解**：

  - 直接跳转：`jmp Label`![1749366708059](./1749366708059.png)
  - 间接跳转：
    - `jmp *%rax` → 跳到 `%rax`存储的代码
    - `jmp *(%rax)` → 跳到 `%rax`存储地址指向的代码
- **PC相对编码**：

  - 机器码将目标指令地址与下条指令地址的差作为编码![1749367539878](./1749367539878.png)![1749367559200](./1749367559200.png)![1749367934550](./1749367934550.png)
  - **补充**：`rep`和 `repz`是空操作，用于优化AMD处理器分支预测

#### if-else汇编示例

- **C正常版本**：![1749369423182](./1749369423182.png)

- **goto版本**：![1749369433012](./1749369433012.png)

- **汇编版本**：

  ![1749369449692](./1749369449692-1758624453817-20-1758624459536-22.png)

#### 条件数据传输指令 cmovX

![1749370757205](./1749370757205.png)

- **代码示例**：
  - C代码：`v = test-expr ? then-expr : else-expr;`
  - 汇编逻辑（C表示）：
    ```c
    v = then-expr;
    ve = else-expr;
    t = test-expr;
    if (!t) v = ve;
    ```
- **问题情况**：![1749371402808](./1749371402808.png)
- **优势**：避免跳转，提高流水线效率
- **局限性**：源操作数可为寄存器/内存，目的操作数必须为寄存器

#### 控制转移 vs 数据传送效率

![1749370250165](./1749370250165.png)

### 循环的汇编实现

#### do_while

- **通用形式**：
  ```c
  do 
      body-statement 
  while (test-expr);
  - **goto表述**：
  ```c
  loop:
      body-statement
      t = test-expr;
      if (t) goto loop;
  ```
- **示例**：
  ![1749373399658](./1749373399658.png)
  ![1749373410420](./1749373410420.png)

#### while

- **翻译方法1 (jump to middle)**：

  - **goto代码**：![1749373802228](./1749373802228.png)
  - **示例**：
    ![1749373863188](./1749373863188.png)
    ![1749373875021](./1749373875021.png)
- **翻译方法2 (guarded-do)**：

  - **goto代码**：![1749374093756](./1749374093756.png)
  - **示例**：
    ![1749374192494](./1749374192494.png)
    ![1749374262376](./1749374262376.png)

#### for

- 原理同while（前面加初始化）

### switch的汇编实现

- **C版本**：![1749375021705](./1749375021705.png)
- **goto版本**：![1749375035381](./1749375035381.png)
- **跳转表生成**：
  - 确定n取值范围
  - 列出所有可能case（如 `n==100`→`*jt[0]=&&loc_A`）
- **汇编实现**：
  - **跳转表**：![1749375912189](./1749375912189.png)
  - **本体**：
    ![1749375920005](./1749375920005.png)
- **优势**：执行时间与case数量无关
- **退化**：当case稀疏时退化为if-else

## 过程

### 栈

- **栈顶地址**：`%rsp`
- **生长方向**：高地址→低地址
- **栈帧写真**：
  ![1749384862384](./1749384862384.png)

### 过程调用与返回

#### 转移控制

- **程序计数器**：`%rip`
- **过程调用指令 call**：
  - 格式：`call label`
  - 效果：
    ```asm
    pushq (next_instruction_address)  // 压入返回地址
    jmp label                         // 跳转目标地址
    ```
- **返回指令 ret**：
  - 等效：`popq %rip`

#### 数据传送

- **参数传递**：
  - 前6个参数用寄存器：![1749386558997](./1749386558997.png)
  - 第7+个参数用栈：
    ![1749386640044](./1749386640044.png)
- **返回值**：`%rax`

#### 内存管理（栈帧）

- **栈帧组成**：
  - 返回地址（call压入）
  - 保存的基地址（`push %rbp; mov %rbp,%rsp`）
  - 函数参数
  - 局部变量
  - 保存的寄存器
- **寄存器使用惯例**：| 类型         | 寄存器                  | 保存责任       |
  | ------------ | ----------------------- | -------------- |
  | Callee-saved | `%rbx,%rbp,%r12-%r15` | 被调用函数保存 |
  | Caller-saved | 其他（除 `%rsp`）     | 调用函数保存   |
- **栈帧示例**：
  ```
  高地址
  +------------------+
  | 调用者参数       | <--- 调用者栈帧
  +------------------+
  | 返回地址         | <--- call压入
  +------------------+
  | 保存的rbp        | <--- %rbp指向此处
  +------------------+
  | 局部变量         |
  +------------------+
  | 保存的寄存器     |
  +------------------+ <--- %rsp指向此处
  低地址
  ```
- **完整示例**：
  ![1749390823453](./1749390823453.png)
  ![1749390865692](./1749390865692.png)

#### 递归实现

- **原理**：每个调用拥有私有栈帧
- **示例**：![1749392378750](./1749392378750.png)![1749392394246](./1749392394246.png)
- **例题**：
  ![1749393112447](./1749393112447.png)
  **答案**：
  
  ```c
  if (x == 0) return 0;
  unsigned long nx = x >> 2;
  long rv = rfun(nx);
  return rv + x;
  ```

## 数组

### 一维数组

- **寻址**：基址 + 索引 × 元素大小
  ```asm
  movl (%rdi, %rsi, 4), %eax  // eax = arr[rsi]
  ```
- **示意图**：
  ![1749393800483](./1749393800483.png)

### 高维数组（嵌套数组）

- **存储原则**：行优先
- **地址计算**：`A[i][j]地址 = 基址 + (i * cols + j) * 元素大小`
- **示意图**：
  ![1749393850696](./1749393850696.png)

### 多层数组（指针数组）

- **与高维数组区别**：
  - 元素是指针（指向独立数组）
  - 内部数组长度可不一致
- **示例**：
  ![1749394227154](./1749394227154.png)
  ![1749394233714](./1749394233714.png)

### 结构体

- **内存布局**：成员按声明顺序存储（含对齐填充）
- **字节对齐规则**：
  - char(1), short(2), int(4), long/指针(8)
  - 结构体对齐 = 成员最大对齐要求的整数倍
- **示例**：![1749394672918](./1749394672918.png)![1749394752044](./1749394752044.png)
- **对齐原因**：内存以4/8字节为单位访问

### 联合体

- 所有成员共享内存（大小=最大成员）
  ![1749394966756](./1749394966756.png)

### 内存布局总览

![1749395079022](./1749395079022.png)

### 缓冲区溢出

#### 产生原因

- 边界检查缺失（如栈字符数组越界）
- 不安全库函数：`gets()`, `strcpy()`, `scanf()`等

#### 攻击类型

| 类型 | 机制                          | 特点                   |
| ---- | ----------------------------- | ---------------------- |
| CI   | 覆盖返回地址指向恶意代码      | 需注入代码到栈         |
| ROP  | 链式调用已有代码片段(gadgets) | 绕过不可执行栈(NX)保护 |

#### 防御措施

- **栈随机化**：随机变化栈基址
- **栈破坏检测**：插入/检查金丝雀值
- **限制可执行区域**：标记栈为不可执行(NX)

```

```
